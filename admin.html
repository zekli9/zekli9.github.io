<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Gesture Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; width: calc(100% - 20px); }
        #start-btn { 
            background: #007bff; border: none; color: white; padding: 12px 24px; 
            border-radius: 5px; font-size: 16px; margin-top: 10px; pointer-events: auto;
        }
        #webcam { position: absolute; bottom: 10px; right: 10px; width: 100px; height: auto; border-radius: 8px; opacity: 0.5; transform: scaleX(-1); border: 1px solid #fff; }
        .controls { display: flex; gap: 10px; margin-top: 10px; }
        .btn-small { background: rgba(255,255,255,0.2); border: 1px solid #fff; color: white; padding: 5px 10px; border-radius: 4px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
    <div id="ui">
        <button id="start-btn">Tap to Start Camera</button>
        <div class="controls">
            <button class="btn-small" onclick="window.changeShape('sphere')">Sphere</button>
            <button class="btn-small" onclick="window.changeShape('heart')">Heart</button>
            <button class="btn-small" onclick="window.changeShape('saturn')">Saturn</button>
        </div>
    </div>
    <video id="webcam" autoplay playsinline></video>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false }); // Antialias off for mobile performance
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 5;

        // --- Particles ---
        const COUNT = 5000; // Lower count for mobile CPUs
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(COUNT * 3);
        const targets = new Float32Array(COUNT * 3);
        
        for(let i=0; i<COUNT*3; i++) positions[i] = (Math.random()-0.5)*10;
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({ size: 0.04, color: 0x00ffff, blending: THREE.AdditiveBlending });
        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // --- Hand Tracking ---
        let handX = 0, handY = 0, isHandActive = false;
        const videoElement = document.getElementById('webcam');
        const startBtn = document.getElementById('start-btn');

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5 });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandActive = true;
                const landmark = results.multiHandLandmarks[0][8]; // Index tip
                // Optimized mapping for mobile aspect ratios
                handX = (landmark.x - 0.5) * -8; 
                handY = (landmark.y - 0.5) * -12;
            } else {
                isHandActive = false;
            }
        });

        startBtn.addEventListener('click', () => {
            startBtn.style.display = 'none';
            const cameraTrack = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 480, height: 360
            });
            cameraTrack.start();
        });

        // --- Shape Logic ---
        window.changeShape = (type) => {
            for(let i=0; i<COUNT; i++) {
                let x, y, z;
                if(type === 'sphere') {
                    const u = Math.random(); const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    x = 2 * Math.sin(phi) * Math.cos(theta);
                    y = 2 * Math.sin(phi) * Math.sin(theta);
                    z = 2 * Math.cos(phi);
                } else if(type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    x = 0.12 * (16 * Math.pow(Math.sin(t), 3));
                    y = 0.12 * (13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t));
                    z = (Math.random()-0.5) * 0.5;
                } else { // Saturn
                    const angle = Math.random() * Math.PI * 2;
                    const r = 2.5 + Math.random() * 0.5;
                    x = Math.cos(angle) * r;
                    y = Math.sin(angle) * r * 0.4;
                    z = Math.sin(angle) * r;
                }
                targets[i*3] = x; targets[i*3+1] = y; targets[i*3+2] = z;
            }
        };
        window.changeShape('sphere');

        function animate() {
            requestAnimationFrame(animate);
            const pos = geometry.attributes.position.array;
            for(let i=0; i<COUNT*3; i+=3) {
                let tx = targets[i] + (isHandActive ? handX : 0);
                let ty = targets[i+1] + (isHandActive ? handY : 0);
                let tz = targets[i+2];
                pos[i] += (tx - pos[i]) * 0.1;
                pos[i+1] += (ty - pos[i+1]) * 0.1;
                pos[i+2] += (tz - pos[i+2]) * 0.1;
            }
            geometry.attributes.position.needsUpdate = true;
            points.rotation.y += 0.005;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
