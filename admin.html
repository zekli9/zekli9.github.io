01.20 21:23
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI Hand-Controlled Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; }
        video { position: absolute; bottom: 20px; right: 20px; width: 200px; border-radius: 10px; opacity: 0.7; transform: scaleX(-1); }
        .hint { font-size: 0.8em; opacity: 0.7; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="ui">
        <h1>Hand Particle Morph</h1>
        <p>Show your hand to the camera.</p>
        <p class="hint">Space: Change Shape | Pinch: Explode Effect</p>
    </div>
    <video id="webcam" autoplay playsinline></video>
    <div id="container"></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        camera.position.z = 5;

        // --- 2. Particle System ---
        const COUNT = 10000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(COUNT * 3);
        const targets = new Float32Array(COUNT * 3);
        const colors = new Float32Array(COUNT * 3);
        
        for(let i=0; i<COUNT; i++) {
            positions[i*3] = (Math.random()-0.5)*10;
            positions[i*3+1] = (Math.random()-0.5)*10;
            positions[i*3+2] = (Math.random()-0.5)*10;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({ size: 0.025, vertexColors: true, blending: THREE.AdditiveBlending });
        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // --- 3. Hand Tracking Logic ---
        let handX = 0, handY = 0, isHandActive = false;
        const videoElement = document.getElementById('webcam');

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandActive = true;
                const landmark = results.multiHandLandmarks[0][8]; // Index Finger Tip
                // Map 0-1 range to Three.js scene coordinates
                handX = (landmark.x - 0.5) * -15; 
                handY = (landmark.y - 0.5) * -10;
            } else {
                isHandActive = false;
            }
        });

        const tracker = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        tracker.start();

        // --- 4. Morphing & Animation ---
        let shapeMode = 'sphere';
        function updateTargets() {
            const color = new THREE.Color();
            for(let i=0; i<COUNT; i++) {
                let x, y, z;
                if(shapeMode === 'sphere') {
                    const phi = Math.acos(-1 + (2 * i) / COUNT);
                    const theta = Math.sqrt(COUNT * Math.PI) * phi;
                    x = 2 * Math.cos(theta) * Math.sin(phi);
                    y = 2 * Math.sin(theta) * Math.sin(phi);
                    z = 2 * Math.cos(phi);
                    color.setHex(0x00ffff);
                } else {
                    const t = Math.random() * Math.PI * 2;
                    x = 0.15 * (16 * Math.pow(Math.sin(t), 3));
                    y = 0.15 * (13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t));
                    z = (Math.random()-0.5);
                    color.setHex(0xff0055);
                }
                targets[i*3] = x; targets[i*3+1] = y; targets[i*3+2] = z;
                colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
            }
            geometry.attributes.color.needsUpdate = true;
        }

        updateTargets();
        window.addEventListener('keydown', (e) => { 
            if(e.code === 'Space') { 
                shapeMode = shapeMode === 'sphere' ? 'heart' : 'sphere'; 
                updateTargets(); 
            } 
        });

        function animate() {
            requestAnimationFrame(animate);
            const pos = geometry.attributes.position.array;
            
            for(let i=0; i<COUNT; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                // Move towards shape target
                let tx = targets[ix], ty = targets[iy], tz = targets[iz];
                
                // If hand is active, shift target towards hand position
                if(isHandActive) {
                    tx += handX; ty += handY;
                }

                pos[ix] += (tx - pos[ix]) * 0.05;
                pos[iy] += (ty - pos[iy]) * 0.05;
                pos[iz] += (tz - pos[iz]) * 0.05;
            }
            geometry.attributes.position.needsUpdate = true;
            points.rotation.y += 0.005;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>

